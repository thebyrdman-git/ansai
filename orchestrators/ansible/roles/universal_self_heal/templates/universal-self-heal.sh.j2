#!/bin/bash
# Universal Self-Healing System for TestServer
# Applies to: {{ service.name }}
# Auto-detects, fixes, and reports issues

set -e

# Service configuration
SERVICE_NAME="{{ service.name }}"
SERVICE_PORT="{{ service.port }}"
SERVICE_DOMAIN="{{ service.domain | default('N/A') }}"
OWNER_EMAIL="{{ owner_email }}"
CRITICAL="{{ service.critical | default('false') }}"
SOCKET_ACTIVATED="{{ service.socket_activated | default(false) | lower }}"

# For socket-activated services, check the .socket unit instead of .service
if [[ "$SOCKET_ACTIVATED" == "true" ]]; then
    SYSTEMD_UNIT="${SERVICE_NAME}.socket"
else
    SYSTEMD_UNIT="${SERVICE_NAME}.service"
fi

# Paths
LOG_FILE="/var/log/self-heal-{{ service.name }}.log"
REPORT_FILE="/tmp/self-heal-{{ service.name }}-$(date +%s).txt"
STATUS_FILE="/var/run/{{ service.name }}-heal-status"

# SMTP Configuration
SMTP_SERVER="{{ smtp_server }}"
SMTP_PORT="{{ smtp_port }}"
SMTP_USER="{{ smtp_user }}"
SMTP_PASS="{{ smtp_password }}"

# AI Configuration
AI_ENABLED="{{ ai_analysis_enabled | lower }}"
AI_BACKEND="{{ ai_backend | default('groq') }}"

# Groq
GROQ_API_KEY="{{ groq_api_key }}"
GROQ_MODEL="{{ groq_model }}"
GROQ_API_URL="{{ groq_api_url }}"

# Ollama (local)
OLLAMA_URL="{{ ollama_url }}"
OLLAMA_MODEL="{{ ollama_model }}"

# LiteLLM (proxy)
LITELLM_URL="{{ litellm_url }}"
LITELLM_MODEL="{{ litellm_model }}"

# OpenAI
OPENAI_API_KEY="{{ openai_api_key }}"
OPENAI_MODEL="{{ openai_model }}"
OPENAI_API_URL="{{ openai_api_url }}"

# Alert Configuration
ALERT_METHOD="{{ alert_method | default('email') }}"
WEBHOOK_URL="{{ webhook_url }}"
WEBHOOK_FORMAT="{{ webhook_format | default('slack') }}"

# Logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] [$SERVICE_NAME] $*" | tee -a "$LOG_FILE"
}

# Report builder
report() {
    echo "$*" | tee -a "$REPORT_FILE"
}

# Initialize report
init_report() {
    cat > "$REPORT_FILE" <<EOF
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¤– TestServer Self-Healing Report
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Service: $SERVICE_NAME
{% if service.domain %}Domain: $SERVICE_DOMAIN{% endif %}
Port: $SERVICE_PORT
Priority: $([ "$CRITICAL" = "true" ] && echo "CRITICAL" || echo "Standard")

Time: $(date)
Host: $(hostname)

AUTOMATIC ISSUE RESOLUTION

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EOF
}

# Send webhook notification
send_webhook() {
    local title="$1"
    local status="$2"
    local color="$3"
    
    if [ -z "$WEBHOOK_URL" ]; then
        return 0
    fi
    
    local body=$(cat "$REPORT_FILE" | head -50)  # Truncate for webhook
    
    case "$WEBHOOK_FORMAT" in
        slack)
            curl -s -X POST "$WEBHOOK_URL" \
                -H "Content-Type: application/json" \
                -d @- <<EOFSLACK
{
    "attachments": [{
        "color": "$color",
        "title": "$title",
        "text": "Service: $SERVICE_NAME\nStatus: $status\nHost: $(hostname)",
        "fields": [
            {"title": "Port", "value": "$SERVICE_PORT", "short": true},
            {"title": "Time", "value": "$(date)", "short": true}
        ],
        "footer": "ANSAI Self-Healing",
        "mrkdwn_in": ["text"]
    }]
}
EOFSLACK
            ;;
        discord)
            curl -s -X POST "$WEBHOOK_URL" \
                -H "Content-Type: application/json" \
                -d @- <<EOFDISCORD
{
    "embeds": [{
        "title": "$title",
        "description": "Service: $SERVICE_NAME\\nStatus: $status",
        "color": $([ "$color" = "good" ] && echo "3066993" || echo "15158332"),
        "fields": [
            {"name": "Host", "value": "$(hostname)", "inline": true},
            {"name": "Port", "value": "$SERVICE_PORT", "inline": true}
        ],
        "footer": {"text": "ANSAI Self-Healing"}
    }]
}
EOFDISCORD
            ;;
        generic|*)
            curl -s -X POST "$WEBHOOK_URL" \
                -H "Content-Type: application/json" \
                -d @- <<EOFGENERIC
{
    "title": "$title",
    "service": "$SERVICE_NAME",
    "status": "$status",
    "host": "$(hostname)",
    "port": "$SERVICE_PORT",
    "timestamp": "$(date -Iseconds)",
    "body": $(echo "$body" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))")
}
EOFGENERIC
            ;;
    esac
    
    log "Webhook notification sent to $WEBHOOK_FORMAT endpoint"
}

# Send alert report (email, webhook, or both)
send_email_report() {
    local subject="$1"
    local success="$2"
    
    if [ "$success" = "true" ]; then
        icon="âœ…"
        status="RESOLVED"
        priority="info"
        color="good"
    else
        icon="âŒ"
        status="FAILED"
        priority="crit"
        color="danger"
    fi
    
    # Add system status to report
    cat >> "$REPORT_FILE" <<EOF

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Post-Healing System Status
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Service: $(systemctl is-active $SYSTEMD_UNIT 2>/dev/null || echo "UNKNOWN")
Enabled: $(systemctl is-enabled $SYSTEMD_UNIT 2>/dev/null || echo "UNKNOWN")
Uptime: $(systemctl show $SYSTEMD_UNIT --property=ActiveEnterTimestamp --value 2>/dev/null | cut -d' ' -f2-4 || echo "N/A")
Type: $([ "$SOCKET_ACTIVATED" = "true" ] && echo "Socket-Activated" || echo "Regular Service")

Recent Logs:
$(journalctl -u $SERVICE_NAME -n 5 --no-pager 2>/dev/null || echo "No logs available")

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

All ANSAI Services Status:
$(systemctl list-units --type=service --state=running --no-pager | grep -E "{{ monitored_services | map(attribute='name') | join('|') }}" || echo "Unable to list services")

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
End Report - ANSAI Self-Healing System
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

View all healing logs: journalctl -t ansai-self-heal
Check service: systemctl status $SYSTEMD_UNIT
View this service logs: journalctl -u $SYSTEMD_UNIT -n 100
EOF

    # Send alerts based on configuration
    case "$ALERT_METHOD" in
        email)
            send_email_notification "$subject" "$status"
            ;;
        webhook)
            send_webhook "$icon ANSAI: $SERVICE_NAME - $status" "$status" "$color"
            ;;
        both)
            send_email_notification "$subject" "$status"
            send_webhook "$icon ANSAI: $SERVICE_NAME - $status" "$status" "$color"
            ;;
        none)
            log "Alerts disabled - skipping notification"
            ;;
    esac
    
    # Always log to systemd journal
    systemd-cat -t ansai-self-heal -p $priority < "$REPORT_FILE"
    
    # Save status
    echo "last_heal=$(date +%s)" > "$STATUS_FILE"
    echo "last_status=$status" >> "$STATUS_FILE"
    echo "service=$SERVICE_NAME" >> "$STATUS_FILE"
}

# Send email notification
send_email_notification() {
    local subject="$1"
    local status="$2"
    
    python3 << PYPYTHON
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import sys

try:
    with open("$REPORT_FILE", "r") as f:
        body = f.read()
    
    msg = MIMEMultipart()
    msg['From'] = "$SMTP_USER"
    msg['To'] = "$OWNER_EMAIL"
    msg['Subject'] = "$icon ANSAI: $SERVICE_NAME - $status"
    msg.attach(MIMEText(body, 'plain'))
    
    server = smtplib.SMTP("$SMTP_SERVER", $SMTP_PORT)
    server.starttls()
    server.login("$SMTP_USER", "$SMTP_PASS")
    server.send_message(msg)
    server.quit()
    print("Email sent successfully")
    sys.exit(0)
except Exception as e:
    print(f"Failed to send email: {e}")
    sys.exit(1)
PYPYTHON
    
    local email_result=$?
    
    if [ $email_result -eq 0 ]; then
        log "Email report sent to $OWNER_EMAIL"
    else
        log "WARNING: Failed to send email report"
    fi
}

# AI-Powered Root Cause Analysis
ai_analyze_failure() {
    if [ "$AI_ENABLED" != "true" ]; then
        return 0
    fi
    
    # Check if we have the required config for the selected backend
    case "$AI_BACKEND" in
        groq)
            if [ -z "$GROQ_API_KEY" ]; then
                log "âš ï¸  AI analysis skipped: GROQ_API_KEY not set"
                return 0
            fi
            ;;
        ollama)
            if ! curl -s "$OLLAMA_URL/api/tags" >/dev/null 2>&1; then
                log "âš ï¸  AI analysis skipped: Ollama not running at $OLLAMA_URL"
                return 0
            fi
            ;;
        openai)
            if [ -z "$OPENAI_API_KEY" ]; then
                log "âš ï¸  AI analysis skipped: OPENAI_API_KEY not set"
                return 0
            fi
            ;;
        litellm)
            if ! curl -s "$LITELLM_URL/health" >/dev/null 2>&1; then
                log "âš ï¸  AI analysis skipped: LiteLLM not running at $LITELLM_URL"
                return 0
            fi
            ;;
    esac
    
    log "ğŸ¤– Performing AI root cause analysis via $AI_BACKEND..."
    report ""
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report "ğŸ¤– AI-POWERED ROOT CAUSE ANALYSIS"
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report ""
    
    # Gather diagnostic data
    local service_status=$(systemctl status $SYSTEMD_UNIT --no-pager 2>&1 | head -20)
    local recent_logs=$(journalctl -u $SERVICE_NAME -n 50 --no-pager 2>&1)
    local system_info=$(free -h && df -h && uptime)
    
    # Build AI prompt
    local prompt="You are an expert Linux systems administrator analyzing a service failure. Be concise and specific.

SERVICE FAILURE REPORT:
Service Name: $SERVICE_NAME
Port: $SERVICE_PORT
Domain: $SERVICE_DOMAIN

SERVICE STATUS:
$service_status

RECENT LOGS (last 50 lines):
$recent_logs

SYSTEM RESOURCES:
$system_info

Provide a BRIEF root cause analysis in this format:
1. ROOT CAUSE: (1-2 sentences max)
2. WHY IT FAILED: (2-3 bullet points)
3. RECOMMENDED FIX: (specific commands or config changes)
4. PREVENTION: (1-2 sentences on how to prevent recurrence)

Be specific, actionable, and concise. Focus on the most likely cause based on the logs."
    
    local ai_response=""
    local model_used=""
    
    # Call appropriate AI backend
    case "$AI_BACKEND" in
        groq)
            model_used="$GROQ_MODEL via Groq"
            ai_response=$(curl -s -X POST "$GROQ_API_URL" \
                -H "Authorization: Bearer $GROQ_API_KEY" \
                -H "Content-Type: application/json" \
                -d @- <<EOFCURL
{
    "model": "$GROQ_MODEL",
    "messages": [
        {"role": "system", "content": "You are a Linux systems expert. Provide concise, actionable root cause analysis."},
        {"role": "user", "content": $(echo "$prompt" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))")}
    ],
    "temperature": 0.3,
    "max_tokens": 500
}
EOFCURL
            )
            ;;
        ollama)
            model_used="$OLLAMA_MODEL via Ollama (local)"
            ai_response=$(curl -s -X POST "$OLLAMA_URL/api/chat" \
                -H "Content-Type: application/json" \
                -d @- <<EOFCURL
{
    "model": "$OLLAMA_MODEL",
    "messages": [
        {"role": "system", "content": "You are a Linux systems expert. Provide concise, actionable root cause analysis."},
        {"role": "user", "content": $(echo "$prompt" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))")}
    ],
    "stream": false
}
EOFCURL
            )
            ;;
        openai)
            model_used="$OPENAI_MODEL via OpenAI"
            ai_response=$(curl -s -X POST "$OPENAI_API_URL" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @- <<EOFCURL
{
    "model": "$OPENAI_MODEL",
    "messages": [
        {"role": "system", "content": "You are a Linux systems expert. Provide concise, actionable root cause analysis."},
        {"role": "user", "content": $(echo "$prompt" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))")}
    ],
    "temperature": 0.3,
    "max_tokens": 500
}
EOFCURL
            )
            ;;
        litellm)
            model_used="$LITELLM_MODEL via LiteLLM"
            ai_response=$(curl -s -X POST "$LITELLM_URL/v1/chat/completions" \
                -H "Content-Type: application/json" \
                -d @- <<EOFCURL
{
    "model": "$LITELLM_MODEL",
    "messages": [
        {"role": "system", "content": "You are a Linux systems expert. Provide concise, actionable root cause analysis."},
        {"role": "user", "content": $(echo "$prompt" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read()))")}
    ],
    "temperature": 0.3,
    "max_tokens": 500
}
EOFCURL
            )
            ;;
    esac
    
    # Extract and format response (handle both OpenAI and Ollama response formats)
    local analysis=$(echo "$ai_response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    # OpenAI/Groq/LiteLLM format
    if 'choices' in data and len(data['choices']) > 0:
        print(data['choices'][0]['message']['content'])
    # Ollama format
    elif 'message' in data and 'content' in data['message']:
        print(data['message']['content'])
    elif 'error' in data:
        print(f\"AI Error: {data['error'].get('message', str(data['error']))}\")
    else:
        print('AI analysis unavailable')
except Exception as e:
    print(f'Error parsing AI response: {e}')
" 2>&1)
    
    if [ -n "$analysis" ] && ! echo "$analysis" | grep -q "Error"; then
        report "$analysis"
        report ""
        report "Analysis powered by: $model_used"
        log "âœ… AI analysis completed"
    else
        report "AI analysis failed: $analysis"
        log "âš ï¸  AI analysis failed or unavailable"
    fi
    report ""
}

# Healing Strategy: Service Restart
heal_service_restart() {
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report "ISSUE DETECTED: $SERVICE_NAME is not running"
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report ""
    report "DIAGNOSIS:"
    report "  â€¢ Service status: $(systemctl is-active $SYSTEMD_UNIT 2>&1 || echo 'inactive')"
    report "  â€¢ Last exit status: $(systemctl show $SYSTEMD_UNIT --property=ExecMainStatus --value 2>/dev/null || echo 'unknown')"
    report "  â€¢ Memory usage: $(systemctl show $SYSTEMD_UNIT --property=MemoryCurrent --value 2>/dev/null | awk '{print $1/1024/1024 " MB"}' || echo 'unknown')"
    report ""
    report "HEALING STRATEGY: Standard Service Restart"
    report "  Action: systemctl restart $SYSTEMD_UNIT"
    report ""
    
    log "Attempting service restart for $SYSTEMD_UNIT..."
    
    local restart_output=$(systemctl restart $SYSTEMD_UNIT 2>&1)
    report "Restart command output:"
    report "$restart_output"
    report ""
    
    sleep 5
    
    if systemctl is-active --quiet $SYSTEMD_UNIT; then
        report "âœ… SUCCESS: Service restarted and is now active"
        report ""
        report "HOW IT WAS FIXED:"
        report "  1. Detected $SERVICE_NAME was inactive/failed"
        report "  2. Executed: systemctl restart $SYSTEMD_UNIT"
        report "  3. Waited 5 seconds for startup"
        report "  4. Verified service is active"
        {% if service.port %}report "  5. Service listening on port $SERVICE_PORT"{% endif %}
        report ""
        report "ROOT CAUSE: Service crash or unexpected termination"
        report "  Possible reasons:"
        report "    â€¢ Out of memory (OOM killer)"
        report "    â€¢ Unhandled exception in application"
        report "    â€¢ External signal (SIGTERM/SIGKILL)"
        report "    â€¢ Configuration error"
        report ""
        report "RESOLUTION: Standard systemd restart restored functionality"
        report "HEALING TIME: ~5 seconds"
        report "CONFIDENCE: High"
        report ""
        report "RECOMMENDATION:"
        report "  Check recent logs for root cause: journalctl -u $SERVICE_NAME -n 100"
        
        log "âœ… Service restart successful for $SERVICE_NAME"
        send_email_report "Service Restarted" "true"
        return 0
    else
        report "âŒ Service restart completed but service is still not active"
        report "  Current status: $(systemctl status $SYSTEMD_UNIT --no-pager | head -n 20)"
        log "âŒ Service restart failed for $SERVICE_NAME"
        return 1
    fi
}

# Healing Strategy: Port Conflict Resolution
heal_port_conflict() {
    {% if service.port %}
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report "ISSUE DETECTED: Port conflict on $SERVICE_PORT"
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report ""
    
    local port_user=$(lsof -ti :$SERVICE_PORT 2>/dev/null || echo "")
    
    if [ -z "$port_user" ]; then
        report "Port $SERVICE_PORT is not occupied - no conflict"
        return 1
    fi
    
    local proc_name=$(ps -p "$port_user" -o comm= 2>/dev/null || echo "unknown")
    local proc_user=$(ps -p "$port_user" -o user= 2>/dev/null || echo "unknown")
    
    report "DIAGNOSIS:"
    report "  â€¢ Port $SERVICE_PORT is occupied"
    report "  â€¢ Occupying PID: $port_user"
    report "  â€¢ Process name: $proc_name"
    report "  â€¢ Process owner: $proc_user"
    report "  â€¢ Expected service: $SERVICE_NAME"
    report ""
    
    # Check if it's a stale process of the same service
    if ps -p "$port_user" -o cmd= | grep -q "$SERVICE_NAME"; then
        report "HEALING STRATEGY: Kill Stale Process"
        report "  Detected: Stale $SERVICE_NAME process"
        report "  Action: Kill PID $port_user and restart service"
        report ""
        
        log "Killing stale $SERVICE_NAME process (PID: $port_user)"
        kill -9 "$port_user" 2>&1 | tee -a "$REPORT_FILE"
        sleep 2
        
        systemctl restart $SYSTEMD_UNIT
        sleep 5
        
        if systemctl is-active --quiet $SYSTEMD_UNIT; then
            report ""
            report "âœ… SUCCESS: Stale process removed, service restarted"
            report ""
            report "HOW IT WAS FIXED:"
            report "  1. Detected stale $SERVICE_NAME process on port $SERVICE_PORT"
            report "  2. Forcefully terminated stale process (PID $port_user)"
            report "  3. Restarted $SYSTEMD_UNIT"
            report "  4. Service successfully claimed port $SERVICE_PORT"
            report ""
            report "ROOT CAUSE: Previous service instance didn't terminate cleanly"
            report "RESOLUTION: Stale process killed, fresh instance started"
            report "HEALING TIME: ~7 seconds"
            report "CONFIDENCE: High"
            
            log "âœ… Port conflict resolved for $SERVICE_NAME"
            send_email_report "Port Conflict Resolved (Stale Process)" "true"
            return 0
        fi
    else
        report "HEALING STRATEGY: Identify and Report Conflict"
        report "  WARNING: Port occupied by different service ($proc_name)"
        report "  Action: Report conflict - manual review needed"
        report ""
        report "âŒ REQUIRES MANUAL INTERVENTION:"
        report "  Port $SERVICE_PORT is occupied by: $proc_name (PID $port_user)"
        report "  This may be:"
        report "    â€¢ A configuration error (wrong port assignment)"
        report "    â€¢ A rogue process that needs investigation"
        report "    â€¢ A service that should be using a different port"
        report ""
        report "  To resolve manually:"
        report "    1. Investigate: ps -p $port_user -f"
        report "    2. Check config: Check if $SERVICE_NAME should use a different port"
        report "    3. If safe to kill: sudo kill $port_user && sudo systemctl restart $SYSTEMD_UNIT"
        report ""
        
        log "Port conflict requires manual intervention (different service)"
        send_email_report "Port Conflict - Manual Review Required" "false"
        return 1
    fi
    {% else %}
    return 1
    {% endif %}
}

# Healing Strategy: Configuration Validation
heal_config_validation() {
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report "ISSUE DETECTED: Configuration may be invalid"
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report ""
    
    # Service-specific config validation
    case "$SERVICE_NAME" in
        traefik)
            report "HEALING STRATEGY: Traefik Configuration Validation"
            if command -v traefik &> /dev/null; then
                local config_check=$(traefik --configFile=/etc/traefik/traefik.yml --dry-run 2>&1 || echo "FAILED")
                report "  Config validation: $config_check"
                
                if echo "$config_check" | grep -q "Configuration loaded"; then
                    report "  âœ… Configuration is valid"
                    systemctl restart $SYSTEMD_UNIT
                    sleep 3
                    
                    if systemctl is-active --quiet $SYSTEMD_UNIT; then
                        report ""
                        report "âœ… SUCCESS: Service restarted with valid config"
                        log "âœ… Traefik config validated and service restarted"
                        send_email_report "Configuration Validated" "true"
                        return 0
                    fi
                else
                    report "  âŒ Configuration has errors"
                    report "  Manual fix required - check config files"
                    send_email_report "Invalid Configuration - Manual Fix Required" "false"
                    return 1
                fi
            fi
            ;;
        *)
            report "  No specific config validation for $SERVICE_NAME"
            return 1
            ;;
    esac
}

# Main healing orchestration
main() {
    log "ğŸ¤– Self-healing check initiated for $SERVICE_NAME"
    init_report
    
    # Check if service is actually down
    if systemctl is-active --quiet $SYSTEMD_UNIT; then
        log "$SERVICE_NAME is running - no healing needed"
        exit 0
    fi
    
    log "âš ï¸  $SERVICE_NAME is DOWN - beginning healing procedures"
    report "ALERT: $SERVICE_NAME has stopped responding"
    report ""
    
    # Run AI analysis before attempting healing
    ai_analyze_failure
    
    # Try enabled healing strategies in order
    {% for strategy in service.healing_strategies %}
    {% if strategy == 'service_restart' %}
    if heal_service_restart; then
        exit 0
    fi
    {% elif strategy == 'port_conflict' %}
    if heal_port_conflict; then
        exit 0
    fi
    {% elif strategy == 'config_validation' %}
    if heal_config_validation; then
        exit 0
    fi
    {% endif %}
    {% endfor %}
    
    # All strategies failed
    report ""
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report "âŒ ALL HEALING STRATEGIES FAILED"
    report "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    report ""
    report "Service: $SERVICE_NAME"
    report "Status: STILL DOWN after healing attempts"
    report ""
    report "MANUAL INTERVENTION REQUIRED:"
    report ""
    report "1. SSH to server:"
    report "   ssh {{ ansible_user }}@testserver.local"
    report ""
    report "2. Check service status:"
    report "   sudo systemctl status $SYSTEMD_UNIT"
    report ""
    report "3. View recent logs:"
    report "   sudo journalctl -u $SERVICE_NAME -n 100"
    report ""
    report "4. Check system resources:"
    report "   free -h && df -h"
    report ""
    report "5. Try manual restart:"
    report "   sudo systemctl restart $SYSTEMD_UNIT"
    report ""
    report "6. If still failing, check:"
    report "   â€¢ Configuration files"
    report "   â€¢ Dependencies (database, network, etc.)"
    report "   â€¢ System logs: journalctl -xe"
    report "   â€¢ Disk space and permissions"
    report ""
    {% if service.critical %}
    report "âš ï¸  CRITICAL SERVICE - IMMEDIATE ATTENTION REQUIRED"
    report ""
    {% endif %}
    
    log "âŒ Self-healing failed for $SERVICE_NAME - escalating to owner"
    send_email_report "Self-Healing Failed - Urgent Manual Action Required" "false"
    exit 1
}

# Execute
main

